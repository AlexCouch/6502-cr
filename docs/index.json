{"repository_name":"6502-cr","body":"# 6502-cr\nA 6502 emulation written in crystal\n\n## Instructions Implemented\n\n* LDX immediate mode\n* LDY immediate mode\n* JSR\n* RTS\n","program":{"html_id":"6502-cr/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"6502-cr","program":true,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"6502-cr/CPU","path":"CPU.html","kind":"struct","full_name":"CPU","name":"CPU","abstract":false,"superclass":{"html_id":"6502-cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"6502-cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"6502-cr/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"6502-cr/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"6502-cr","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"The core CPU that will have the methods and IV's necessary to emulate the 6502 microprocessor","summary":"<p>The core CPU that will have the methods and IV's necessary to emulate the 6502 microprocessor</p>","class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":4,"url":null},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"id":"advance_next_ins-instance-method","html_id":"advance_next_ins-instance-method","name":"advance_next_ins","doc":"This is the same as next_ins except it decrements the cycles_remaining.","summary":"<p>This is the same as next_ins except it decrements the cycles_remaining.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":49,"url":null},"def":{"name":"advance_next_ins","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"next_ins = self.memory[self.program_counter]\nself.program_counter = self.program_counter + 1\nself.cycles_remaining = self.cycles_remaining - 1\nnext_ins\n"}},{"id":"cycles_remaining:Int32-instance-method","html_id":"cycles_remaining:Int32-instance-method","name":"cycles_remaining","doc":"The cycles remaining for the execution of an instruction.\nSome instructions take more cycles than others, so after the first byte is fetched from memory using next_ins,\nthen there is 1 less cycle remaining for that instruction.\nExample: LDX_IMM has 2 cycles, but after the first call to next_ins drops that down to 1, so when it's being processed, this will be set to 1","summary":"<p>The cycles remaining for the execution of an instruction.</p>","abstract":false,"args":[],"args_string":" : Int32","args_html":" : Int32","location":{"filename":"src/6502.cr","line_number":39,"url":null},"def":{"name":"cycles_remaining","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@cycles_remaining"}},{"id":"cycles_remaining=(cycles_remaining)-instance-method","html_id":"cycles_remaining=(cycles_remaining)-instance-method","name":"cycles_remaining=","doc":"The cycles remaining for the execution of an instruction.\nSome instructions take more cycles than others, so after the first byte is fetched from memory using next_ins,\nthen there is 1 less cycle remaining for that instruction.\nExample: LDX_IMM has 2 cycles, but after the first call to next_ins drops that down to 1, so when it's being processed, this will be set to 1","summary":"<p>The cycles remaining for the execution of an instruction.</p>","abstract":false,"args":[{"name":"cycles_remaining","doc":null,"default_value":"","external_name":"cycles_remaining","restriction":""}],"args_string":"(cycles_remaining)","args_html":"(cycles_remaining)","location":{"filename":"src/6502.cr","line_number":39,"url":null},"def":{"name":"cycles_remaining=","args":[{"name":"cycles_remaining","doc":null,"default_value":"","external_name":"cycles_remaining","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@cycles_remaining = cycles_remaining"}},{"id":"execute-instance-method","html_id":"execute-instance-method","name":"execute","doc":"This will execute the loaded program by taking the first byte and \ndecoding it as an instruction, and continuing to decode instructions until the next byte read is 0. \nIf it fails to decode it, it will print an error.","summary":"<p>This will execute the loaded program by taking the first byte and  decoding it as an instruction, and continuing to decode instructions until the next byte read is 0.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":90,"url":null},"def":{"name":"execute","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"next_ins = next_ins()\nwhile !(next_ins == 0)\n  case Instructions.new(next_ins)\n  when Instructions::LDX_IMM\n    self.cycles_remaining = 1\n    value = advance_next_ins()\n    self.reg_x = value\n  when Instructions::LDY_IMM\n    self.cycles_remaining = 1\n    value = advance_next_ins()\n    self.reg_y = value\n  when Instructions::JSR\n    self.cycles_remaining = 6\n    lower_byte = advance_next_ins()\n    higher_byte = (advance_next_ins().to_u16 << 8).to_u16\n    jump_target = (higher_byte | lower_byte).to_u16\n    self.stack_push(self.program_counter)\n    self.program_counter = jump_target - 1\n    self.cycles_remaining = self.cycles_remaining - 2\n  when Instructions::RTS\n    self.cycles_remaining = 5\n    lower_byte = (self.stack_pop.to_u16).to_u16\n    higher_byte = (self.stack_pop.to_u16 << 8).to_u16\n    jump_target = (higher_byte | lower_byte).to_u16\n    self.cycles_remaining = self.cycles_remaining - 1\n    self.program_counter = jump_target + 1\n    self.cycles_remaining = self.cycles_remaining - 2\n  else\n    puts(\"Failed to decode instruction: #{next_ins} @ #{self.program_counter}\")\n    return\n  end\n  next_ins = next_ins()\nend\n"}},{"id":"load_program(program:Array(UInt8))-instance-method","html_id":"load_program(program:Array(UInt8))-instance-method","name":"load_program","doc":"Loads a program into memory at address 0x0200","summary":"<p>Loads a program into memory at address 0x0200</p>","abstract":false,"args":[{"name":"program","doc":null,"default_value":"","external_name":"program","restriction":"Array(UInt8)"}],"args_string":"(program : Array(UInt8))","args_html":"(program : Array(UInt8))","location":{"filename":"src/6502.cr","line_number":132,"url":null},"def":{"name":"load_program","args":[{"name":"program","doc":null,"default_value":"","external_name":"program","restriction":"Array(UInt8)"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"program.each_with_index do |b, index|\n  self.memory[index] = b\nend"}},{"id":"memory:Memory-instance-method","html_id":"memory:Memory-instance-method","name":"memory","doc":"The memory of the cpu","summary":"<p>The memory of the cpu</p>","abstract":false,"args":[],"args_string":" : Memory","args_html":" : <a href=\"Memory.html\">Memory</a>","location":{"filename":"src/6502.cr","line_number":34,"url":null},"def":{"name":"memory","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@memory"}},{"id":"next_ins-instance-method","html_id":"next_ins-instance-method","name":"next_ins","doc":"Get the next instruction in memory without affecting the cycles remaining. This is mostly used for getting the first byte in an instruction, which would count as the first cycle of an instruction. This will increment the program counter","summary":"<p>Get the next instruction in memory without affecting the cycles remaining.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":42,"url":null},"def":{"name":"next_ins","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"next_ins = self.memory[self.program_counter]\nself.program_counter = self.program_counter + 1\nnext_ins\n"}},{"id":"processor_status:BitArray-instance-method","html_id":"processor_status:BitArray-instance-method","name":"processor_status","doc":"The processor status holds bits specific to certain statuses of the processor\n\nThe bits are as follows:\n\n```\n  0 : Carry flag\n  1 : Zero flag\n  2 : Interrupt disable\n  3 : Decimal mode\n  4 : Break command\n  5 : Overflow flag\n  6 : Negative flag\n```","summary":"<p>The processor status holds bits specific to certain statuses of the processor</p>","abstract":false,"args":[],"args_string":" : BitArray","args_html":" : BitArray","location":{"filename":"src/6502.cr","line_number":32,"url":null},"def":{"name":"processor_status","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"BitArray","visibility":"Public","body":"@processor_status"}},{"id":"program_counter:UInt16-instance-method","html_id":"program_counter:UInt16-instance-method","name":"program_counter","doc":"The program counter, which is used to indicate the next instruction to load from the program in memory.\nThis can be changed by using jump instructions, calling a subroutine, or exiting a subrouting or by an interrupt","summary":"<p>The program counter, which is used to indicate the next instruction to load from the program in memory.</p>","abstract":false,"args":[],"args_string":" : UInt16","args_html":" : UInt16","location":{"filename":"src/6502.cr","line_number":13,"url":null},"def":{"name":"program_counter","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt16","visibility":"Public","body":"@program_counter"}},{"id":"program_counter=(program_counter:UInt16)-instance-method","html_id":"program_counter=(program_counter:UInt16)-instance-method","name":"program_counter=","doc":"The program counter, which is used to indicate the next instruction to load from the program in memory.\nThis can be changed by using jump instructions, calling a subroutine, or exiting a subrouting or by an interrupt","summary":"<p>The program counter, which is used to indicate the next instruction to load from the program in memory.</p>","abstract":false,"args":[{"name":"program_counter","doc":null,"default_value":"","external_name":"program_counter","restriction":"UInt16"}],"args_string":"(program_counter : UInt16)","args_html":"(program_counter : UInt16)","location":{"filename":"src/6502.cr","line_number":13,"url":null},"def":{"name":"program_counter=","args":[{"name":"program_counter","doc":null,"default_value":"","external_name":"program_counter","restriction":"UInt16"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@program_counter = program_counter"}},{"id":"reg_a:UInt8-instance-method","html_id":"reg_a:UInt8-instance-method","name":"reg_a","doc":"Accumulator register","summary":"<p>Accumulator register</p>","abstract":false,"args":[],"args_string":" : UInt8","args_html":" : UInt8","location":{"filename":"src/6502.cr","line_number":10,"url":null},"def":{"name":"reg_a","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt8","visibility":"Public","body":"@reg_a"}},{"id":"reg_a=(reg_a:UInt8)-instance-method","html_id":"reg_a=(reg_a:UInt8)-instance-method","name":"reg_a=","doc":"Accumulator register","summary":"<p>Accumulator register</p>","abstract":false,"args":[{"name":"reg_a","doc":null,"default_value":"","external_name":"reg_a","restriction":"UInt8"}],"args_string":"(reg_a : UInt8)","args_html":"(reg_a : UInt8)","location":{"filename":"src/6502.cr","line_number":10,"url":null},"def":{"name":"reg_a=","args":[{"name":"reg_a","doc":null,"default_value":"","external_name":"reg_a","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@reg_a = reg_a"}},{"id":"reg_x:UInt8-instance-method","html_id":"reg_x:UInt8-instance-method","name":"reg_x","doc":"X register","summary":"<p>X register</p>","abstract":false,"args":[],"args_string":" : UInt8","args_html":" : UInt8","location":{"filename":"src/6502.cr","line_number":6,"url":null},"def":{"name":"reg_x","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt8","visibility":"Public","body":"@reg_x"}},{"id":"reg_x=(reg_x:UInt8)-instance-method","html_id":"reg_x=(reg_x:UInt8)-instance-method","name":"reg_x=","doc":"X register","summary":"<p>X register</p>","abstract":false,"args":[{"name":"reg_x","doc":null,"default_value":"","external_name":"reg_x","restriction":"UInt8"}],"args_string":"(reg_x : UInt8)","args_html":"(reg_x : UInt8)","location":{"filename":"src/6502.cr","line_number":6,"url":null},"def":{"name":"reg_x=","args":[{"name":"reg_x","doc":null,"default_value":"","external_name":"reg_x","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@reg_x = reg_x"}},{"id":"reg_y:UInt8-instance-method","html_id":"reg_y:UInt8-instance-method","name":"reg_y","doc":"Y register","summary":"<p>Y register</p>","abstract":false,"args":[],"args_string":" : UInt8","args_html":" : UInt8","location":{"filename":"src/6502.cr","line_number":8,"url":null},"def":{"name":"reg_y","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt8","visibility":"Public","body":"@reg_y"}},{"id":"reg_y=(reg_y:UInt8)-instance-method","html_id":"reg_y=(reg_y:UInt8)-instance-method","name":"reg_y=","doc":"Y register","summary":"<p>Y register</p>","abstract":false,"args":[{"name":"reg_y","doc":null,"default_value":"","external_name":"reg_y","restriction":"UInt8"}],"args_string":"(reg_y : UInt8)","args_html":"(reg_y : UInt8)","location":{"filename":"src/6502.cr","line_number":8,"url":null},"def":{"name":"reg_y=","args":[{"name":"reg_y","doc":null,"default_value":"","external_name":"reg_y","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@reg_y = reg_y"}},{"id":"stack_pointer:UInt8-instance-method","html_id":"stack_pointer:UInt8-instance-method","name":"stack_pointer","doc":"The pointer to the next place on the stack to be pushed. This starts at the top and moves downwards, starting at 0x01FF and ending at 0x0100.\nThis is an 8-bit register which holds the low 8 bits of the next location on the stack to be pushed to\nWhen the stack is pushed, this decrements, when the stack is popped, it is incremented\nThis register does not handle overflows so overflows will have to be handled manually","summary":"<p>The pointer to the next place on the stack to be pushed.</p>","abstract":false,"args":[],"args_string":" : UInt8","args_html":" : UInt8","location":{"filename":"src/6502.cr","line_number":18,"url":null},"def":{"name":"stack_pointer","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt8","visibility":"Public","body":"@stack_pointer"}},{"id":"stack_pointer=(stack_pointer:UInt8)-instance-method","html_id":"stack_pointer=(stack_pointer:UInt8)-instance-method","name":"stack_pointer=","doc":"The pointer to the next place on the stack to be pushed. This starts at the top and moves downwards, starting at 0x01FF and ending at 0x0100.\nThis is an 8-bit register which holds the low 8 bits of the next location on the stack to be pushed to\nWhen the stack is pushed, this decrements, when the stack is popped, it is incremented\nThis register does not handle overflows so overflows will have to be handled manually","summary":"<p>The pointer to the next place on the stack to be pushed.</p>","abstract":false,"args":[{"name":"stack_pointer","doc":null,"default_value":"","external_name":"stack_pointer","restriction":"UInt8"}],"args_string":"(stack_pointer : UInt8)","args_html":"(stack_pointer : UInt8)","location":{"filename":"src/6502.cr","line_number":18,"url":null},"def":{"name":"stack_pointer=","args":[{"name":"stack_pointer","doc":null,"default_value":"","external_name":"stack_pointer","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@stack_pointer = stack_pointer"}},{"id":"stack_pop-instance-method","html_id":"stack_pop-instance-method","name":"stack_pop","doc":"Pop a byte off the stack\n\nThis will increment the stack pointer and decrement the cycles remaining\nThis will take up one cycle to complete\n\nThis returns the value popped from the stack at stack_pointer + 1 ","summary":"<p>Pop a byte off the stack</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":80,"url":null},"def":{"name":"stack_pop","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"value = self.memory[self.stack_pointer + 1]\nself.stack_pointer = self.stack_pointer + 1\nself.cycles_remaining = self.cycles_remaining - 1\nvalue\n"}},{"id":"stack_push(value:UInt8)-instance-method","html_id":"stack_push(value:UInt8)-instance-method","name":"stack_push","doc":"Push a byte onto the stack portion of memory. See Memory::data for more info on where the stack is in memory.\nThis counts as a cycle so when using this, make sure you have enough cycles set\nTodo: Add assertion for cycles_remaining","summary":"<p>Push a byte onto the stack portion of memory.</p>","abstract":false,"args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"args_string":"(value : UInt8)","args_html":"(value : UInt8)","location":{"filename":"src/6502.cr","line_number":59,"url":null},"def":{"name":"stack_push","args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.memory[self.stack_pointer] = value\nself.stack_pointer = self.stack_pointer - 1\nself.cycles_remaining = self.cycles_remaining - 1\n"}},{"id":"stack_push(value:UInt16)-instance-method","html_id":"stack_push(value:UInt16)-instance-method","name":"stack_push","doc":"Push a word onto the stack. \nBecause 6502 is in little endian, it will take the low byte then the high byte in that order on the stack","summary":"<p>Push a word onto the stack.</p>","abstract":false,"args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt16"}],"args_string":"(value : UInt16)","args_html":"(value : UInt16)","location":{"filename":"src/6502.cr","line_number":67,"url":null},"def":{"name":"stack_push","args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt16"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"lower_byte = ((value & 65280) >> 8).to_u8\nself.stack_push(lower_byte)\nhigher_byte = (value & 255).to_u8\nself.stack_push(higher_byte)\n"}}],"macros":[],"types":[]},{"html_id":"6502-cr/Instructions","path":"Instructions.html","kind":"enum","full_name":"Instructions","name":"Instructions","abstract":false,"superclass":null,"ancestors":[{"html_id":"6502-cr/Enum","kind":"struct","full_name":"Enum","name":"Enum"},{"html_id":"6502-cr/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"6502-cr/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"6502-cr/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"6502-cr","program":false,"enum":true,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[{"id":"LDX_IMM","name":"LDX_IMM","value":"162_u8","doc":"This instruction will load a byte into the X register.\n\nThis instruction is 2 cycles and 2 bytes and operate as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read byte and load into X\n```","summary":"<p>This instruction will load a byte into the X register.</p>"},{"id":"LDY_IMM","name":"LDY_IMM","value":"160_u8","doc":"This instruction will load a byte into the Y register.\n\nThis instruction is 2 cycles and 2 bytes and operate as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read byte and load into Y\n```","summary":"<p>This instruction will load a byte into the Y register.</p>"},{"id":"JSR","name":"JSR","value":"32_u8","doc":"This will read a word from the program and push the current program counter onto the stack then setting the program counter to the acquired word.\n\nThis instruction is 7 cycles and 3 bytes\n\nNormally in the hardware, the lower byte read is called ADL\nand the higher byte read is called ADH\nIn the hardware, we also have PCH (program counter high) and PCL (program counter low)\nThe hardware will spend two cycles to set the ADL->PCL and ADH->PCH\n\n  Vocabulary:\n      ADL : Target Address Low\n      ADH : Target Address high\n      PCL : Program Counter low\n      PCH : Program Counter high\n      AD  : Target Address\n      PC  : Program Counter\n\nSo the hardware is really like this:\n```\n  Cycle 1    Fetch Opcode\n  Cycle 2    Read ADL\n  Cycle 3    Push PCH\n  Cycle 4    Push PCL\n  Cycle 5    Fetch ADH\n  Cycle 6    ADL->PCL\n  Cycle 7    ADH->PCH\n```\n\nSource: http://archive.6502.org/datasheets/synertek_programming_manual.pdf p118\n\nOur cycles are like this:\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADL\nCycle 3    Read ADH\nCycle 4    AD = ADH | ADL\nCycle 5    Push PCH\nCycle 6    Push PCL\nCycle 7    AD->PC\n```","summary":"<p>This will read a word from the program and push the current program counter onto the stack then setting the program counter to the acquired word.</p>"},{"id":"RTS","name":"RTS","value":"96_u8","doc":"This will return from a subroutine by popping a word off the stack and setting the program counter to it + 1\n\nThis instruction is 6 cycles and 1 byte.\n```\nCycle 1    Fetch Opcode\nCycle 2    Pop ADL\nCycle 3    Pop ADH\nCycle 4    AD = ADH | ADL\nCycle 5    AD->PC\nCycle 6    PC->PC+1\n```","summary":"<p>This will return from a subroutine by popping a word off the stack and setting the program counter to it + 1</p>"}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"jsr?-instance-method","html_id":"jsr?-instance-method","name":"jsr?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":235,"url":null},"def":{"name":"jsr?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == JSR"}},{"id":"ldx_imm?-instance-method","html_id":"ldx_imm?-instance-method","name":"ldx_imm?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":185,"url":null},"def":{"name":"ldx_imm?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDX_IMM"}},{"id":"ldy_imm?-instance-method","html_id":"ldy_imm?-instance-method","name":"ldy_imm?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":193,"url":null},"def":{"name":"ldy_imm?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDY_IMM"}},{"id":"rts?-instance-method","html_id":"rts?-instance-method","name":"rts?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":247,"url":null},"def":{"name":"rts?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == RTS"}}],"macros":[],"types":[]},{"html_id":"6502-cr/Memory","path":"Memory.html","kind":"struct","full_name":"Memory","name":"Memory","abstract":false,"superclass":{"html_id":"6502-cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"6502-cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"6502-cr/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"6502-cr/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"6502-cr","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":139,"url":null},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"id":"[](index:UInt16)-instance-method","html_id":"[](index:UInt16)-instance-method","name":"[]","doc":"Read at a 16-bit address","summary":"<p>Read at a 16-bit address</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt16"}],"args_string":"(index : UInt16)","args_html":"(index : UInt16)","location":{"filename":"src/6502.cr","line_number":152,"url":null},"def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt16"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index]"}},{"id":"[](index:UInt8)-instance-method","html_id":"[](index:UInt8)-instance-method","name":"[]","doc":"Read at an 8-bit address","summary":"<p>Read at an 8-bit address</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt8"}],"args_string":"(index : UInt8)","args_html":"(index : UInt8)","location":{"filename":"src/6502.cr","line_number":157,"url":null},"def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index]"}},{"id":"[]=(index:Int32,value:UInt8)-instance-method","html_id":"[]=(index:Int32,value:UInt8)-instance-method","name":"[]=","doc":"Use a 32-bit address to store an 8-bit value","summary":"<p>Use a 32-bit address to store an 8-bit value</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"Int32"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"args_string":"(index : Int32, value : UInt8)","args_html":"(index : Int32, value : UInt8)","location":{"filename":"src/6502.cr","line_number":162,"url":null},"def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"Int32"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index] = value"}},{"id":"[]=(index:UInt16,value:UInt8)-instance-method","html_id":"[]=(index:UInt16,value:UInt8)-instance-method","name":"[]=","doc":"Use a 16-bit address to store an 8-bit value","summary":"<p>Use a 16-bit address to store an 8-bit value</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt16"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"args_string":"(index : UInt16, value : UInt8)","args_html":"(index : UInt16, value : UInt8)","location":{"filename":"src/6502.cr","line_number":167,"url":null},"def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt16"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index] = value"}},{"id":"[]=(index:UInt8,value:UInt8)-instance-method","html_id":"[]=(index:UInt8,value:UInt8)-instance-method","name":"[]=","doc":"Use an 8-bit address to store an 8-bit value","summary":"<p>Use an 8-bit address to store an 8-bit value</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt8"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"args_string":"(index : UInt8, value : UInt8)","args_html":"(index : UInt8, value : UInt8)","location":{"filename":"src/6502.cr","line_number":172,"url":null},"def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt8"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index] = value"}},{"id":"data:Array(UInt8)-instance-method","html_id":"data:Array(UInt8)-instance-method","name":"data","doc":"The actual stored data\n  The first page ($0000 - $00FF) is called the zero page\n  The second page ($0100 - $01FF) is reserved for the system stack and cannot be relocated\n  The last 6 bytes are reserved for the following\n      $FFFA-$FFFB : non-maskable interrupt handler\n      $FFFC-$FFFD : power reset handler\n      $FFFE-$FFFF : BRK/interrupt request handler\n  Any other locations are free to use by the user\ngetter data = StaticArray(UInt8, 65536).new(0)","summary":"<p>The actual stored data   The first page ($0000 - $00FF) is called the zero page   The second page ($0100 - $01FF) is reserved for the system stack and cannot be relocated   The last 6 bytes are reserved for the following       $FFFA-$FFFB : non-maskable interrupt handler       $FFFC-$FFFD : power reset handler       $FFFE-$FFFF : BRK/interrupt request handler   Any other locations are free to use by the user getter data = StaticArray(UInt8, 65536).new(0)</p>","abstract":false,"args":[],"args_string":" : Array(UInt8)","args_html":" : Array(UInt8)","location":{"filename":"src/6502.cr","line_number":149,"url":null},"def":{"name":"data","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@data"}}],"macros":[],"types":[]}]}}