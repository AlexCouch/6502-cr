crystal_doc_search_index_callback({"repository_name":"6502-cr","body":"# 6502-cr\nA 6502 emulation written in crystal\n\nFor a list of instructions implemented, see docs/Instructions.html opened in a browser.\n\nThis is a crude yet simple implementation not meant to be sturdy or robust. This is meant as a learning exercise and may improve over time.\n","program":{"html_id":"6502-cr/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"6502-cr","program":true,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"6502-cr/CPU","path":"CPU.html","kind":"struct","full_name":"CPU","name":"CPU","abstract":false,"superclass":{"html_id":"6502-cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"6502-cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"6502-cr/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"6502-cr/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"6502-cr","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"The core CPU that will have the methods and IV's necessary to emulate the 6502 microprocessor","summary":"<p>The core CPU that will have the methods and IV's necessary to emulate the 6502 microprocessor</p>","class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":5,"url":null},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"id":"advance_next_ins-instance-method","html_id":"advance_next_ins-instance-method","name":"advance_next_ins","doc":"This is the same as next_ins except it decrements the cycles_remaining.","summary":"<p>This is the same as next_ins except it decrements the cycles_remaining.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":50,"url":null},"def":{"name":"advance_next_ins","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"next_ins = self.memory[self.program_counter]\nself.program_counter = self.program_counter + 1\nself.cycles_remaining = self.cycles_remaining - 1\nnext_ins\n"}},{"id":"cycles_remaining:Int32-instance-method","html_id":"cycles_remaining:Int32-instance-method","name":"cycles_remaining","doc":"The cycles remaining for the execution of an instruction.\nSome instructions take more cycles than others, so after the first byte is fetched from memory using next_ins,\nthen there is 1 less cycle remaining for that instruction.\nExample: LDX_IMM has 2 cycles, but after the first call to next_ins drops that down to 1, so when it's being processed, this will be set to 1","summary":"<p>The cycles remaining for the execution of an instruction.</p>","abstract":false,"args":[],"args_string":" : Int32","args_html":" : Int32","location":{"filename":"src/6502.cr","line_number":40,"url":null},"def":{"name":"cycles_remaining","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@cycles_remaining"}},{"id":"cycles_remaining=(cycles_remaining)-instance-method","html_id":"cycles_remaining=(cycles_remaining)-instance-method","name":"cycles_remaining=","doc":"The cycles remaining for the execution of an instruction.\nSome instructions take more cycles than others, so after the first byte is fetched from memory using next_ins,\nthen there is 1 less cycle remaining for that instruction.\nExample: LDX_IMM has 2 cycles, but after the first call to next_ins drops that down to 1, so when it's being processed, this will be set to 1","summary":"<p>The cycles remaining for the execution of an instruction.</p>","abstract":false,"args":[{"name":"cycles_remaining","doc":null,"default_value":"","external_name":"cycles_remaining","restriction":""}],"args_string":"(cycles_remaining)","args_html":"(cycles_remaining)","location":{"filename":"src/6502.cr","line_number":40,"url":null},"def":{"name":"cycles_remaining=","args":[{"name":"cycles_remaining","doc":null,"default_value":"","external_name":"cycles_remaining","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@cycles_remaining = cycles_remaining"}},{"id":"execute-instance-method","html_id":"execute-instance-method","name":"execute","doc":"This will execute the loaded program by taking the first byte and \ndecoding it as an instruction, and continuing to decode instructions until the next byte read is 0. \nIf it fails to decode it, it will print an error.","summary":"<p>This will execute the loaded program by taking the first byte and  decoding it as an instruction, and continuing to decode instructions until the next byte read is 0.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":91,"url":null},"def":{"name":"execute","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"ins = next_ins()\nwhile !(ins == 0)\n  case Instructions.new(ins)\n  when Instructions::LDX_IMM\n    self.cycles_remaining = 1\n    value = advance_next_ins()\n    self.reg_x = value\n  when Instructions::LDX_ABS\n    self.cycles_remaining = 3\n    lower = (advance_next_ins() << 8).to_u16\n    higher = advance_next_ins()\n    address = lower | higher\n    self.reg_x = self.memory[address]\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::LDX_ABS_Y\n    self.cycles_remaining = 3\n    lower = (advance_next_ins() << 8).to_u16\n    higher = advance_next_ins()\n    address = lower | higher\n    self.reg_x = self.memory[address + self.reg_y]\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::LDX_ZERO\n    self.cycles_remaining = 2\n    adh = advance_next_ins()\n    addr = (0 << 8).to_u16 | adh\n    self.reg_x = self.memory[addr]\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::LDX_ZERO_Y\n    self.cycles_remaining = 3\n    adh = advance_next_ins()\n    addr = (0 << 8).to_u16 | adh\n    self.reg_x = self.memory[addr + self.reg_y]\n    self.cycles_remaining = self.cycles_remaining - 2\n  when Instructions::STX_ZERO\n    self.cycles_remaining = 2\n    value = advance_next_ins()\n    addr = (0 << 8).to_u16 | value\n    self.memory[addr] = self.reg_x\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::STX_ZERO_Y\n    self.cycles_remaining = 3\n    value = advance_next_ins()\n    addr = (0 << 8).to_u16 | value\n    self.memory[addr + self.reg_y] = self.reg_x\n    self.cycles_remaining = self.cycles_remaining - 2\n  when Instructions::STX_ABS\n    self.cycles_remaining = 3\n    adl = advance_next_ins()\n    adh = advance_next_ins()\n    addr = (adl << 8).to_u16 | adh\n    self.memory[addr] = self.reg_x\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::LDY_IMM\n    self.cycles_remaining = 1\n    value = advance_next_ins()\n    self.reg_y = value\n  when Instructions::LDY_ZERO\n    self.cycles_remaining = 2\n    adh = advance_next_ins()\n    addr = (0 << 8).to_u16 | adh\n    self.reg_y = self.memory[addr]\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::LDY_ZERO_X\n    self.cycles_remaining = 3\n    adh = advance_next_ins()\n    addr = (0 << 8).to_u16 | adh\n    self.reg_y = self.memory[addr + self.reg_x]\n    self.cycles_remaining = self.cycles_remaining - 2\n  when Instructions::LDY_ABS\n    self.cycles_remaining = 3\n    lower = (advance_next_ins() << 8).to_u16\n    higher = advance_next_ins()\n    address = lower | higher\n    self.reg_y = self.memory[address]\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::LDY_ABS_X\n    self.cycles_remaining = 4\n    lower = (advance_next_ins() << 8).to_u16\n    higher = advance_next_ins()\n    address = lower | higher\n    self.reg_y = self.memory[address + self.reg_x]\n    self.cycles_remaining = self.cycles_remaining - 2\n  when Instructions::STY_ZERO\n    self.cycles_remaining = 2\n    value = advance_next_ins()\n    addr = (0 << 8).to_u16 | value\n    self.memory[addr] = self.reg_y\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::STY_ZERO_X\n    self.cycles_remaining = 3\n    value = advance_next_ins()\n    addr = (0 << 8).to_u16 | value\n    self.memory[addr + self.reg_x] = self.reg_y\n    self.cycles_remaining = self.cycles_remaining - 2\n  when Instructions::STY_ABS\n    self.cycles_remaining = 3\n    adl = advance_next_ins()\n    adh = advance_next_ins()\n    addr = (adl << 8).to_u16 | adh\n    self.memory[addr] = self.reg_y\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::JSR\n    self.cycles_remaining = 6\n    lower_byte = advance_next_ins()\n    higher_byte = (advance_next_ins().to_u16 << 8).to_u16\n    jump_target = (higher_byte | lower_byte).to_u16\n    self.stack_push(self.program_counter - 1)\n    self.program_counter = jump_target\n    self.cycles_remaining = self.cycles_remaining - 2\n  when Instructions::RTS\n    self.cycles_remaining = 5\n    lower_byte = (self.stack_pop.to_u16).to_u16\n    higher_byte = (self.stack_pop.to_u16 << 8).to_u16\n    jump_target = (higher_byte | lower_byte).to_u16\n    self.cycles_remaining = self.cycles_remaining - 1\n    self.program_counter = jump_target + 1\n    self.cycles_remaining = self.cycles_remaining - 2\n  when Instructions::LDA_IMM\n    self.cycles_remaining = 1\n    value = advance_next_ins()\n    self.reg_a = value\n  when Instructions::LDA_ZERO\n    self.cycles_remaining = 2\n    adh = advance_next_ins()\n    addr = (0 << 8).to_u16 | adh\n    self.reg_a = self.memory[addr]\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::LDA_ABS\n    self.cycles_remaining = 3\n    lower = (advance_next_ins() << 8).to_u16\n    higher = advance_next_ins()\n    address = lower | higher\n    self.reg_a = self.memory[address]\n  when Instructions::STA_ZERO\n    self.cycles_remaining = 2\n    adh = advance_next_ins()\n    addr = (0 << 8).to_u16 | adh\n    self.memory[addr] = self.reg_a\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::STA_ABS\n    self.cycles_remaining = 3\n    adl = advance_next_ins()\n    adh = advance_next_ins()\n    addr = (adl << 8).to_u16 | adh\n    self.memory[addr] = self.reg_a\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::ADC_IMM\n    self.cycles_remaining = 1\n    value = advance_next_ins()\n    result = (self.reg_a &+ value) &+ self.processor_status.to_slice[0]\n    self.processor_status[0] = (self.reg_a & 128) != (result & 128)\n    overflow = ((~(self.reg_a ^ value)) & (self.reg_a ^ result)) & 128\n    self.reg_a = result\n    self.processor_status[5] = overflow == 128\n    self.processor_status[1] = result == 0\n    self.processor_status[6] = (result & 128) == 128\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::ADC_ZERO\n    self.cycles_remaining = 2\n    adh = advance_next_ins()\n    addr = (0 << 8).to_u16 | adh\n    value = self.memory[addr]\n    result = (self.reg_a &+ value) &+ self.processor_status.to_slice[0]\n    self.processor_status[0] = (self.reg_a & 128) != (result & 128)\n    overflow = ((~(self.reg_a ^ value)) & (self.reg_a ^ result)) & 128\n    self.reg_a = result\n    self.processor_status[5] = overflow == 128\n    self.processor_status[1] = result == 0\n    self.processor_status[6] = (result & 128) == 128\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::ADC_ABS\n    self.cycles_remaining = 3\n    adl = advance_next_ins()\n    adh = advance_next_ins()\n    addr = (adl << 8).to_u16 | adh\n    value = self.memory[addr]\n    result = (self.reg_a &- value) &+ self.processor_status.to_slice[0]\n    self.processor_status[0] = (self.reg_a & 128) != (result & 128)\n    overflow = ((~(self.reg_a ^ value)) & (self.reg_a ^ result)) & 128\n    self.reg_a = result\n    self.processor_status[5] = overflow == 128\n    self.processor_status[1] = result == 0\n    self.processor_status[6] = (result & 128) == 128\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::SBC_ABS\n    self.cycles_remaining = 3\n    adl = advance_next_ins()\n    adh = advance_next_ins()\n    addr = (adl << 8).to_u16 | adh\n    value = self.memory[addr]\n    result = (self.reg_a &- value) &+ self.processor_status.to_slice[0]\n    self.processor_status[0] = (self.reg_a & 128) != (result & 128)\n    overflow = ((~(self.reg_a ^ value)) & (self.reg_a ^ result)) & 128\n    self.reg_a = result\n    self.processor_status[5] = overflow == 128\n    self.processor_status[1] = result == 0\n    self.processor_status[6] = (result & 128) == 128\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::SBC_ZERO\n    self.cycles_remaining = 2\n    adh = advance_next_ins()\n    addr = (0 << 8).to_u16 | adh\n    value = self.memory[addr]\n    result = (self.reg_a &- value) &+ self.processor_status.to_slice[0]\n    self.processor_status[0] = (self.reg_a & 128) != (result & 128)\n    overflow = ((~(self.reg_a ^ value)) & (self.reg_a ^ result)) & 128\n    self.reg_a = result\n    self.processor_status[5] = overflow == 128\n    self.processor_status[1] = result == 0\n    self.processor_status[6] = (result & 128) == 128\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::SBC_IMM\n    self.cycles_remaining = 2\n    value = advance_next_ins()\n    result = (self.reg_a &- value) &+ self.processor_status.to_slice[0]\n    self.processor_status[0] = (self.reg_a & 128) != (result & 128)\n    overflow = ((~(self.reg_a ^ value)) & (self.reg_a ^ result)) & 128\n    self.reg_a = result\n    self.processor_status[5] = overflow == 128\n    self.processor_status[1] = result == 0\n    self.processor_status[6] = (result & 128) == 128\n    self.cycles_remaining = self.cycles_remaining - 1\n  when Instructions::SEC\n    self.cycles_remaining = 1\n    self.processor_status[0] = true\n  when Instructions::CLC\n    self.cycles_remaining = 1\n    self.processor_status[0] = false\n  else\n    puts(\"Failed to decode instruction: #{ins.to_s(16)} @ #{self.program_counter.to_s(16)}\")\n    return\n  end\n  ins = next_ins()\nend\n"}},{"id":"get_processor_status_string-instance-method","html_id":"get_processor_status_string-instance-method","name":"get_processor_status_string","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":349,"url":null},"def":{"name":"get_processor_status_string","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"String.build do |str|\n  if self.processor_status[0] == true\n    str << 1\n  else\n    str << 0\n  end\n  if self.processor_status[1] == true\n    str << 1\n  else\n    str << 0\n  end\n  if self.processor_status[2] == true\n    str << 1\n  else\n    str << 0\n  end\n  if self.processor_status[3] == true\n    str << 1\n  else\n    str << 0\n  end\n  if self.processor_status[4] == true\n    str << 1\n  else\n    str << 0\n  end\n  if self.processor_status[5] == true\n    str << 1\n  else\n    str << 0\n  end\n  if self.processor_status[6] == true\n    str << 1\n  else\n    str << 0\n  end\nend"}},{"id":"load_program(program:Array(UInt8))-instance-method","html_id":"load_program(program:Array(UInt8))-instance-method","name":"load_program","doc":"Loads a program into memory at address 0x0200","summary":"<p>Loads a program into memory at address 0x0200</p>","abstract":false,"args":[{"name":"program","doc":null,"default_value":"","external_name":"program","restriction":"Array(UInt8)"}],"args_string":"(program : Array(UInt8))","args_html":"(program : Array(UInt8))","location":{"filename":"src/6502.cr","line_number":343,"url":null},"def":{"name":"load_program","args":[{"name":"program","doc":null,"default_value":"","external_name":"program","restriction":"Array(UInt8)"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"program.each_with_index do |b, index|\n  self.memory[512 + index] = b\nend"}},{"id":"memory:Memory-instance-method","html_id":"memory:Memory-instance-method","name":"memory","doc":"The memory of the cpu","summary":"<p>The memory of the cpu</p>","abstract":false,"args":[],"args_string":" : Memory","args_html":" : <a href=\"Memory.html\">Memory</a>","location":{"filename":"src/6502.cr","line_number":35,"url":null},"def":{"name":"memory","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@memory"}},{"id":"next_ins-instance-method","html_id":"next_ins-instance-method","name":"next_ins","doc":"Get the next instruction in memory without affecting the cycles remaining. This is mostly used for getting the first byte in an instruction, which would count as the first cycle of an instruction. This will increment the program counter","summary":"<p>Get the next instruction in memory without affecting the cycles remaining.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":43,"url":null},"def":{"name":"next_ins","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"next_ins = self.memory[self.program_counter]\nself.program_counter = self.program_counter + 1\nnext_ins\n"}},{"id":"processor_status:BitArray-instance-method","html_id":"processor_status:BitArray-instance-method","name":"processor_status","doc":"The processor status holds bits specific to certain statuses of the processor\n\nThe bits are as follows:\n\n```\n  0 : Carry flag\n  1 : Zero flag\n  2 : Interrupt disable\n  3 : Decimal mode\n  4 : Break command\n  5 : Overflow flag\n  6 : Negative flag\n```","summary":"<p>The processor status holds bits specific to certain statuses of the processor</p>","abstract":false,"args":[],"args_string":" : BitArray","args_html":" : BitArray","location":{"filename":"src/6502.cr","line_number":33,"url":null},"def":{"name":"processor_status","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"BitArray","visibility":"Public","body":"@processor_status"}},{"id":"program_counter:UInt16-instance-method","html_id":"program_counter:UInt16-instance-method","name":"program_counter","doc":"The program counter, which is used to indicate the next instruction to load from the program in memory.\nThis can be changed by using jump instructions, calling a subroutine, or exiting a subrouting or by an interrupt","summary":"<p>The program counter, which is used to indicate the next instruction to load from the program in memory.</p>","abstract":false,"args":[],"args_string":" : UInt16","args_html":" : UInt16","location":{"filename":"src/6502.cr","line_number":14,"url":null},"def":{"name":"program_counter","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt16","visibility":"Public","body":"@program_counter"}},{"id":"program_counter=(program_counter:UInt16)-instance-method","html_id":"program_counter=(program_counter:UInt16)-instance-method","name":"program_counter=","doc":"The program counter, which is used to indicate the next instruction to load from the program in memory.\nThis can be changed by using jump instructions, calling a subroutine, or exiting a subrouting or by an interrupt","summary":"<p>The program counter, which is used to indicate the next instruction to load from the program in memory.</p>","abstract":false,"args":[{"name":"program_counter","doc":null,"default_value":"","external_name":"program_counter","restriction":"UInt16"}],"args_string":"(program_counter : UInt16)","args_html":"(program_counter : UInt16)","location":{"filename":"src/6502.cr","line_number":14,"url":null},"def":{"name":"program_counter=","args":[{"name":"program_counter","doc":null,"default_value":"","external_name":"program_counter","restriction":"UInt16"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@program_counter = program_counter"}},{"id":"reg_a:UInt8-instance-method","html_id":"reg_a:UInt8-instance-method","name":"reg_a","doc":"Accumulator register","summary":"<p>Accumulator register</p>","abstract":false,"args":[],"args_string":" : UInt8","args_html":" : UInt8","location":{"filename":"src/6502.cr","line_number":11,"url":null},"def":{"name":"reg_a","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt8","visibility":"Public","body":"@reg_a"}},{"id":"reg_a=(reg_a:UInt8)-instance-method","html_id":"reg_a=(reg_a:UInt8)-instance-method","name":"reg_a=","doc":"Accumulator register","summary":"<p>Accumulator register</p>","abstract":false,"args":[{"name":"reg_a","doc":null,"default_value":"","external_name":"reg_a","restriction":"UInt8"}],"args_string":"(reg_a : UInt8)","args_html":"(reg_a : UInt8)","location":{"filename":"src/6502.cr","line_number":11,"url":null},"def":{"name":"reg_a=","args":[{"name":"reg_a","doc":null,"default_value":"","external_name":"reg_a","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@reg_a = reg_a"}},{"id":"reg_x:UInt8-instance-method","html_id":"reg_x:UInt8-instance-method","name":"reg_x","doc":"X register","summary":"<p>X register</p>","abstract":false,"args":[],"args_string":" : UInt8","args_html":" : UInt8","location":{"filename":"src/6502.cr","line_number":7,"url":null},"def":{"name":"reg_x","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt8","visibility":"Public","body":"@reg_x"}},{"id":"reg_x=(reg_x:UInt8)-instance-method","html_id":"reg_x=(reg_x:UInt8)-instance-method","name":"reg_x=","doc":"X register","summary":"<p>X register</p>","abstract":false,"args":[{"name":"reg_x","doc":null,"default_value":"","external_name":"reg_x","restriction":"UInt8"}],"args_string":"(reg_x : UInt8)","args_html":"(reg_x : UInt8)","location":{"filename":"src/6502.cr","line_number":7,"url":null},"def":{"name":"reg_x=","args":[{"name":"reg_x","doc":null,"default_value":"","external_name":"reg_x","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@reg_x = reg_x"}},{"id":"reg_y:UInt8-instance-method","html_id":"reg_y:UInt8-instance-method","name":"reg_y","doc":"Y register","summary":"<p>Y register</p>","abstract":false,"args":[],"args_string":" : UInt8","args_html":" : UInt8","location":{"filename":"src/6502.cr","line_number":9,"url":null},"def":{"name":"reg_y","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt8","visibility":"Public","body":"@reg_y"}},{"id":"reg_y=(reg_y:UInt8)-instance-method","html_id":"reg_y=(reg_y:UInt8)-instance-method","name":"reg_y=","doc":"Y register","summary":"<p>Y register</p>","abstract":false,"args":[{"name":"reg_y","doc":null,"default_value":"","external_name":"reg_y","restriction":"UInt8"}],"args_string":"(reg_y : UInt8)","args_html":"(reg_y : UInt8)","location":{"filename":"src/6502.cr","line_number":9,"url":null},"def":{"name":"reg_y=","args":[{"name":"reg_y","doc":null,"default_value":"","external_name":"reg_y","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@reg_y = reg_y"}},{"id":"stack_pointer:UInt8-instance-method","html_id":"stack_pointer:UInt8-instance-method","name":"stack_pointer","doc":"The pointer to the next place on the stack to be pushed. This starts at the top and moves downwards, starting at 0x01FF and ending at 0x0100.\nThis is an 8-bit register which holds the low 8 bits of the next location on the stack to be pushed to\nWhen the stack is pushed, this decrements, when the stack is popped, it is incremented\nThis register does not handle overflows so overflows will have to be handled manually","summary":"<p>The pointer to the next place on the stack to be pushed.</p>","abstract":false,"args":[],"args_string":" : UInt8","args_html":" : UInt8","location":{"filename":"src/6502.cr","line_number":19,"url":null},"def":{"name":"stack_pointer","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"UInt8","visibility":"Public","body":"@stack_pointer"}},{"id":"stack_pointer=(stack_pointer:UInt8)-instance-method","html_id":"stack_pointer=(stack_pointer:UInt8)-instance-method","name":"stack_pointer=","doc":"The pointer to the next place on the stack to be pushed. This starts at the top and moves downwards, starting at 0x01FF and ending at 0x0100.\nThis is an 8-bit register which holds the low 8 bits of the next location on the stack to be pushed to\nWhen the stack is pushed, this decrements, when the stack is popped, it is incremented\nThis register does not handle overflows so overflows will have to be handled manually","summary":"<p>The pointer to the next place on the stack to be pushed.</p>","abstract":false,"args":[{"name":"stack_pointer","doc":null,"default_value":"","external_name":"stack_pointer","restriction":"UInt8"}],"args_string":"(stack_pointer : UInt8)","args_html":"(stack_pointer : UInt8)","location":{"filename":"src/6502.cr","line_number":19,"url":null},"def":{"name":"stack_pointer=","args":[{"name":"stack_pointer","doc":null,"default_value":"","external_name":"stack_pointer","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@stack_pointer = stack_pointer"}},{"id":"stack_pop-instance-method","html_id":"stack_pop-instance-method","name":"stack_pop","doc":"Pop a byte off the stack\n\nThis will increment the stack pointer and decrement the cycles remaining\nThis will take up one cycle to complete\n\nThis returns the value popped from the stack at stack_pointer + 1 ","summary":"<p>Pop a byte off the stack</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":81,"url":null},"def":{"name":"stack_pop","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"value = self.memory[self.stack_pointer + 1]\nself.stack_pointer = self.stack_pointer + 1\nself.cycles_remaining = self.cycles_remaining - 1\nvalue\n"}},{"id":"stack_push(value:UInt8)-instance-method","html_id":"stack_push(value:UInt8)-instance-method","name":"stack_push","doc":"Push a byte onto the stack portion of memory. See Memory::data for more info on where the stack is in memory.\nThis counts as a cycle so when using this, make sure you have enough cycles set\nTodo: Add assertion for cycles_remaining","summary":"<p>Push a byte onto the stack portion of memory.</p>","abstract":false,"args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"args_string":"(value : UInt8)","args_html":"(value : UInt8)","location":{"filename":"src/6502.cr","line_number":60,"url":null},"def":{"name":"stack_push","args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.memory[self.stack_pointer] = value\nself.stack_pointer = self.stack_pointer - 1\nself.cycles_remaining = self.cycles_remaining - 1\n"}},{"id":"stack_push(value:UInt16)-instance-method","html_id":"stack_push(value:UInt16)-instance-method","name":"stack_push","doc":"Push a word onto the stack. \nBecause 6502 is in little endian, it will take the low byte then the high byte in that order on the stack","summary":"<p>Push a word onto the stack.</p>","abstract":false,"args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt16"}],"args_string":"(value : UInt16)","args_html":"(value : UInt16)","location":{"filename":"src/6502.cr","line_number":68,"url":null},"def":{"name":"stack_push","args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt16"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"lower_byte = ((value & 65280) >> 8).to_u8\nself.stack_push(lower_byte)\nhigher_byte = (value & 255).to_u8\nself.stack_push(higher_byte)\n"}}],"macros":[],"types":[]},{"html_id":"6502-cr/Instructions","path":"Instructions.html","kind":"enum","full_name":"Instructions","name":"Instructions","abstract":false,"superclass":null,"ancestors":[{"html_id":"6502-cr/Enum","kind":"struct","full_name":"Enum","name":"Enum"},{"html_id":"6502-cr/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"6502-cr/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"6502-cr/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"6502-cr","program":false,"enum":true,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[{"id":"LDX_IMM","name":"LDX_IMM","value":"162_u8","doc":"This instruction will load an immediate byte into the X register.\n\nThis instruction is 2 cycles and 2 bytes and operate as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read byte and load into X\n```","summary":"<p>This instruction will load an immediate byte into the X register.</p>"},{"id":"LDX_ZERO","name":"LDX_ZERO","value":"165_u8","doc":"This instruction will load a byte into the X register given a higher byte of a zero page address\n\nThis instruction is 3 cycles and 2 bytes\n```\nCycle 1    Fetch Opcode\nCycle 2    Read higher byte from program\nCycle 3    Load from zero page address into X\n```","summary":"<p>This instruction will load a byte into the X register given a higher byte of a zero page address</p>"},{"id":"LDX_ABS","name":"LDX_ABS","value":"174_u8","doc":"This instruction will load a byte from a given 16-bit memory address into the X register.\n\nThis instruction is 4 cycles and 3 bytes and operate as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read ADL\nCycle 3: Read ADH\nCycle 4: Load 8-bit data of address 0x{ADL}{ADH} into X\n```","summary":"<p>This instruction will load a byte from a given 16-bit memory address into the X register.</p>"},{"id":"LDX_ABS_Y","name":"LDX_ABS_Y","value":"190_u8","doc":"This instruction will load a byte from a given 16-bit memory address, indexed to Y\n\nThis instruction is 4 cycles, 3 bytes and operates as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read ADL\nCycle 3: Read ADH\nCycle 4: Load 8-biot data of address 0x{ADL}{ADH}+Y\n```\n\nX and Y registers are known as index registers. They are used to offset an address, such as indexing into an array.\nExample:\n```\narr = ['a', 'b', 'c']\narr[1] #'b'\n```\nThe indexing is easily done with the X and Y registers\n```\nldx #1\nlda $5000, X ;Assuming that the array starts at address 0x5000, we index into 0x5001 using X\n```\n","summary":"<p>This instruction will load a byte from a given 16-bit memory address, indexed to Y</p>"},{"id":"LDX_ZERO_Y","name":"LDX_ZERO_Y","value":"182_u8","doc":"This instruction will load a byte from a given 16-bit memory address, indexed to Y\n\nThis instruction is 4 cycles, 2 bytes and operates as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read ADH\nCycle 3: Load 8-bit data of address 0x00{ADH}+Y\n```\n\nX and Y registers are known as index registers. They are used to offset an address, such as indexing into an array.\nExample:\n```\narr = ['a', 'b', 'c']\narr[1] #'b'\n```\nThe indexing is easily done with the X and Y registers\n```\nldx #1\nlda $50, X ;Assuming that the array starts at address 0x50, we index into 0x51 using X\n```\n","summary":"<p>This instruction will load a byte from a given 16-bit memory address, indexed to Y</p>"},{"id":"STX_ZERO","name":"STX_ZERO","value":"134_u8","doc":"This instruction will store the value in register X in an address in the zero page\n\nThis takes two bytes and three cycles\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADH\nCycle 3    Store contents of X at 0x00{ADH} where ADH is the address within the zero page, and 0x00 is the lower byte of the address\n```","summary":"<p>This instruction will store the value in register X in an address in the zero page</p>"},{"id":"STX_ZERO_Y","name":"STX_ZERO_Y","value":"134_u8","doc":"This instruction will store the value in register X in an address in the zero page\n\nThis takes two bytes and three cycles\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADH\nCycle 3    Store contents of X at 0x00{ADH} where ADH is the address within the zero page, and 0x00 is the lower byte of the address\n```","summary":"<p>This instruction will store the value in register X in an address in the zero page</p>"},{"id":"STX_ABS","name":"STX_ABS","value":"142_u8","doc":"This instruction will store the value in register X in an absolute address\n\nThis takes three bytes and 4 cycles to complete\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADL\nCycle 3    Read ADH\nCycle 4    Store contents of X at 0x{ADL}{ADH}\n```","summary":"<p>This instruction will store the value in register X in an absolute address</p>"},{"id":"STY_ZERO","name":"STY_ZERO","value":"132_u8","doc":"This instruction will store the value in register Y in an address in the zero page\n\nThis takes two bytes and three cycles\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADH\nCycle 3    Store contents of Y at 0x00{ADH} where ADH is the address within the zero page, and 0x00 is the lower byte of the address\n```","summary":"<p>This instruction will store the value in register Y in an address in the zero page</p>"},{"id":"STY_ZERO_X","name":"STY_ZERO_X","value":"148_u8","doc":"This instruction will store the value in register Y in an address in the zero page indexed to X\n\nThis takes two bytes and four cycles\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADH\nCycle 3    \nCycle 4    Store contents of Y at 0x00{ADH}+X where ADH is the address within the zero page, and 0x00 is the lower byte of the address and X is the contents of X register\n```","summary":"<p>This instruction will store the value in register Y in an address in the zero page indexed to X</p>"},{"id":"STY_ABS","name":"STY_ABS","value":"140_u8","doc":"This instruction will store the value in register Y in an absolute address\n\nThis takes three bytes and 4 cycles to complete\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADL\nCycle 3    Read ADH\nCycle 4    Store contents of Y at 0x{ADL}{ADH}\n```","summary":"<p>This instruction will store the value in register Y in an absolute address</p>"},{"id":"LDY_IMM","name":"LDY_IMM","value":"160_u8","doc":"This instruction will load a byte into the Y register.\n\nThis instruction is 2 cycles and 2 bytes and operate as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read byte and load into Y\n```","summary":"<p>This instruction will load a byte into the Y register.</p>"},{"id":"LDY_ZERO","name":"LDY_ZERO","value":"164_u8","doc":"This instruction will load a byte into the Y register given a higher byte of a zero page address\n\nThis instruction is 3 cycles and 2 bytes\n```\nCycle 1    Fetch Opcode\nCycle 2    Read higher byte from program\nCycle 3    Load from zero page address into Y\n```","summary":"<p>This instruction will load a byte into the Y register given a higher byte of a zero page address</p>"},{"id":"LDY_ZERO_X","name":"LDY_ZERO_X","value":"180_u8","doc":"This instruction will load a byte into the Y register given a higher byte of a zero page address\n\nThis instruction is 4 cycles and 2 bytes\n```\nCycle 1    Fetch Opcode\nCycle 2    ADH = Read higher byte from program\nCycle 3    Addr = 0x00{ADH} + X\nCycle 4    Load contents of Addr into Y\n```","summary":"<p>This instruction will load a byte into the Y register given a higher byte of a zero page address</p>"},{"id":"LDY_ABS_X","name":"LDY_ABS_X","value":"188_u8","doc":"This instruction will load a byte from a given 16-bit memory address into the Y register.\n\nThis instruction is 4 cycles and 3 bytes and operate as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read ADL\nCycle 3: Read ADH\nCycle 4: Increment address by X\nCycle 4: Load 8-bit data of address 0x{ADL}{ADH}+X into Y\n```","summary":"<p>This instruction will load a byte from a given 16-bit memory address into the Y register.</p>"},{"id":"LDY_ABS","name":"LDY_ABS","value":"172_u8","doc":"This instruction will load a byte from a given 16-bit memory address into the Y register.\n\nThis instruction is 4 cycles and 3 bytes and operate as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read ADL\nCycle 3: Read ADH\nCycle 4: Load 8-bit data of address 0x{ADL}{ADH} into Y\n```","summary":"<p>This instruction will load a byte from a given 16-bit memory address into the Y register.</p>"},{"id":"LDA_IMM","name":"LDA_IMM","value":"169_u8","doc":"This instruction will load a byte into the A register.\n\nThis instruction is 2 cycles and 2 bytes and operate as follows:\n```\nCycle 1: Fetch Opcode\nCycle 2: Read byte and load into A\n```","summary":"<p>This instruction will load a byte into the A register.</p>"},{"id":"LDA_ZERO","name":"LDA_ZERO","value":"165_u8","doc":"This instruction will load a byte into the A register given a higher byte of a zero page address\n\nThis instruction is 3 cycles and 2 bytes\n```\nCycle 1    Fetch Opcode\nCycle 2    Read higher byte from program\nCycle 3    Load from zero page address into accumulator\n```","summary":"<p>This instruction will load a byte into the A register given a higher byte of a zero page address</p>"},{"id":"LDA_ABS","name":"LDA_ABS","value":"173_u8","doc":"This instruction will load a byte from an absolute address into the accumulator\n\nThis instruction is 4 cycles and 3 bytes\n```\nCycle 1    Fetch Opcode\nCycle 2    Read lower byte\nCycle 3    Read higher byte\nCycle 4    Load byte from given address into accumulator\n```","summary":"<p>This instruction will load a byte from an absolute address into the accumulator</p>"},{"id":"STA_ZERO","name":"STA_ZERO","value":"133_u8","doc":"This instruction will store the value in the accumulator (register A) in an address in the zero page\n\nThis takes two bytes and three cycles\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADH\nCycle 3    Store contents of A at 0x00{ADH} where ADH is the address within the zero page, and 0x00 is the lower byte of the address\n```","summary":"<p>This instruction will store the value in the accumulator (register A) in an address in the zero page</p>"},{"id":"STA_ABS","name":"STA_ABS","value":"141_u8","doc":"This instruction will store the contents of the accumulator into an absolute address\n\nThis instruction is 4 cycles and 3 bytes\n```\nCycle 1    Fetch Opcode\nCycle 2    Read lower byte\nCycle 3    Read higher byte\nCycle 4    Store contents of accumulator into given address\n```","summary":"<p>This instruction will store the contents of the accumulator into an absolute address</p>"},{"id":"ADC_IMM","name":"ADC_IMM","value":"105_u8","doc":"This instruction will add an immediate value into the accumulator (A register) with a carry bit. If the operation overflows beyond 255, then the result with a carry bit of 1 means to interpret the results as 255 + A.\n\nThis instruction takes two bytes and takes three cycles to complete.\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read byte from program\nCycle 3    Add read byte to A, set carry bit if necessary\n```","summary":"<p>This instruction will add an immediate value into the accumulator (A register) with a carry bit.</p>"},{"id":"ADC_ZERO","name":"ADC_ZERO","value":"101_u8","doc":"This instruction will add the contents of an address in the zero page to the accumulator.\n\nThis instruction takes 3 bytes and takes 4 cycles to complete.\n\n```\nCycle 1    Fetch Opcode\nCycle 3    Read ADH\nCycle 4    Add contents of 0x00{ADH} to register A\n```","summary":"<p>This instruction will add the contents of an address in the zero page to the accumulator.</p>"},{"id":"ADC_ABS","name":"ADC_ABS","value":"109_u8","doc":"This instruction will add the contents of an absolute memory location into the accumulator (A register) with a carry bit. \n\nIf the operation overflows beyond 255, then the result with a carry bit of 1 means to interpret the results as 255 + A.\n\nThis instruction takes 3 bytes and takes 4 cycles to complete.\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADL\nCycle 3    Read ADH\nCycle 4    Add contents of 0x{ADL}{ADH} to register A\n```","summary":"<p>This instruction will add the contents of an absolute memory location into the accumulator (A register) with a carry bit.</p>"},{"id":"SBC_IMM","name":"SBC_IMM","value":"233_u8","doc":"This instruction will subtract an immediate value from the accumulator (A register) with a carry bit. \n\nIf the operation underflows below 0, then the result with a carry bit of 1 means to interpret the results as 255 - A.\n\nThis instruction takes two bytes and takes three cycles to complete.\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read byte from program\nCycle 3    Sub read byte from A, set carry bit if necessary\n```","summary":"<p>This instruction will subtract an immediate value from the accumulator (A register) with a carry bit.</p>"},{"id":"SBC_ZERO","name":"SBC_ZERO","value":"229_u8","doc":"This instruction will subtract the contents of an address in the zero page from the accumulator. \n\nIf the operation underflows below 0, then the result with a carry bit of 1 means to interpret the results as 255 - A.\n\nThis instruction takes 3 bytes and takes 4 cycles to complete.\n\n```\nCycle 1    Fetch Opcode\nCycle 3    Read ADH\nCycle 4    Subtract contents of 0x00{ADH} to register A\n```","summary":"<p>This instruction will subtract the contents of an address in the zero page from the accumulator.</p>"},{"id":"SBC_ABS","name":"SBC_ABS","value":"237_u8","doc":"This instruction will add the contents of an absolute memory location into the accumulator (A register) with a carry bit. \n\nIf the operation overflows beyond 255, then the result with a carry bit of 1 means to interpret the results as 255 + A.\n\nThis instruction takes 3 bytes and takes 4 cycles to complete.\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADL\nCycle 3    Read ADH\nCycle 4    Subtract contents of 0x{ADL}{ADH} to register A\n```","summary":"<p>This instruction will add the contents of an absolute memory location into the accumulator (A register) with a carry bit.</p>"},{"id":"JSR","name":"JSR","value":"32_u8","doc":"This will read a word from the program and push the current program counter onto the stack then setting the program counter to the acquired word.\n\nThis instruction is 7 cycles and 3 bytes\n\nNormally in the hardware, the lower byte read is called ADL\nand the higher byte read is called ADH\nIn the hardware, we also have PCH (program counter high) and PCL (program counter low)\nThe hardware will spend two cycles to set the ADL->PCL and ADH->PCH\n\n  Vocabulary:\n      ADL : Target Address Low\n      ADH : Target Address high\n      PCL : Program Counter low\n      PCH : Program Counter high\n      AD  : Target Address\n      PC  : Program Counter\n\nSo the hardware is really like this:\n```\n  Cycle 1    Fetch Opcode\n  Cycle 2    Read ADL\n  Cycle 3    Push PCH\n  Cycle 4    Push PCL\n  Cycle 5    Fetch ADH\n  Cycle 6    ADL->PCL\n  Cycle 7    ADH->PCH\n```\n\nSource: http://archive.6502.org/datasheets/synertek_programming_manual.pdf p118\n\nOur cycles are like this:\n\n```\nCycle 1    Fetch Opcode\nCycle 2    Read ADL\nCycle 3    Read ADH\nCycle 4    AD = ADH | ADL\nCycle 5    Push PCH\nCycle 6    Push PCL\nCycle 7    AD->PC\n```","summary":"<p>This will read a word from the program and push the current program counter onto the stack then setting the program counter to the acquired word.</p>"},{"id":"RTS","name":"RTS","value":"96_u8","doc":"This will return from a subroutine by popping a word off the stack and setting the program counter to it + 1\n\nThis instruction is 6 cycles and 1 byte.\n```\nCycle 1    Fetch Opcode\nCycle 2    Pop ADL\nCycle 3    Pop ADH\nCycle 4    AD = ADH | ADL\nCycle 5    AD->PC\nCycle 6    PC->PC+1\n```","summary":"<p>This will return from a subroutine by popping a word off the stack and setting the program counter to it + 1</p>"},{"id":"SEC","name":"SEC","value":"56_u8","doc":"This instruction will set the carry flag to 1","summary":"<p>This instruction will set the carry flag to 1</p>"},{"id":"CLC","name":"CLC","value":"24_u8","doc":"This instruction will clear the carry flag to 0","summary":"<p>This instruction will clear the carry flag to 0</p>"}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"adc_abs?-instance-method","html_id":"adc_abs?-instance-method","name":"adc_abs?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":691,"url":null},"def":{"name":"adc_abs?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == ADC_ABS"}},{"id":"adc_imm?-instance-method","html_id":"adc_imm?-instance-method","name":"adc_imm?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":668,"url":null},"def":{"name":"adc_imm?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == ADC_IMM"}},{"id":"adc_zero?-instance-method","html_id":"adc_zero?-instance-method","name":"adc_zero?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":678,"url":null},"def":{"name":"adc_zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == ADC_ZERO"}},{"id":"clc?-instance-method","html_id":"clc?-instance-method","name":"clc?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":786,"url":null},"def":{"name":"clc?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == CLC"}},{"id":"jsr?-instance-method","html_id":"jsr?-instance-method","name":"jsr?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":770,"url":null},"def":{"name":"jsr?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == JSR"}},{"id":"lda_abs?-instance-method","html_id":"lda_abs?-instance-method","name":"lda_abs?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":638,"url":null},"def":{"name":"lda_abs?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDA_ABS"}},{"id":"lda_imm?-instance-method","html_id":"lda_imm?-instance-method","name":"lda_imm?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":619,"url":null},"def":{"name":"lda_imm?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDA_IMM"}},{"id":"lda_zero?-instance-method","html_id":"lda_zero?-instance-method","name":"lda_zero?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":628,"url":null},"def":{"name":"lda_zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDA_ZERO"}},{"id":"ldx_abs?-instance-method","html_id":"ldx_abs?-instance-method","name":"ldx_abs?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":455,"url":null},"def":{"name":"ldx_abs?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDX_ABS"}},{"id":"ldx_abs_y?-instance-method","html_id":"ldx_abs_y?-instance-method","name":"ldx_abs_y?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":478,"url":null},"def":{"name":"ldx_abs_y?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDX_ABS_Y"}},{"id":"ldx_imm?-instance-method","html_id":"ldx_imm?-instance-method","name":"ldx_imm?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":436,"url":null},"def":{"name":"ldx_imm?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDX_IMM"}},{"id":"ldx_zero?-instance-method","html_id":"ldx_zero?-instance-method","name":"ldx_zero?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":445,"url":null},"def":{"name":"ldx_zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDX_ZERO"}},{"id":"ldx_zero_y?-instance-method","html_id":"ldx_zero_y?-instance-method","name":"ldx_zero_y?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":500,"url":null},"def":{"name":"ldx_zero_y?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDX_ZERO_Y"}},{"id":"ldy_abs?-instance-method","html_id":"ldy_abs?-instance-method","name":"ldy_abs?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":611,"url":null},"def":{"name":"ldy_abs?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDY_ABS"}},{"id":"ldy_abs_x?-instance-method","html_id":"ldy_abs_x?-instance-method","name":"ldy_abs_x?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":601,"url":null},"def":{"name":"ldy_abs_x?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDY_ABS_X"}},{"id":"ldy_imm?-instance-method","html_id":"ldy_imm?-instance-method","name":"ldy_imm?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":571,"url":null},"def":{"name":"ldy_imm?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDY_IMM"}},{"id":"ldy_zero?-instance-method","html_id":"ldy_zero?-instance-method","name":"ldy_zero?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":580,"url":null},"def":{"name":"ldy_zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDY_ZERO"}},{"id":"ldy_zero_x?-instance-method","html_id":"ldy_zero_x?-instance-method","name":"ldy_zero_x?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":590,"url":null},"def":{"name":"ldy_zero_x?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == LDY_ZERO_X"}},{"id":"rts?-instance-method","html_id":"rts?-instance-method","name":"rts?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":782,"url":null},"def":{"name":"rts?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == RTS"}},{"id":"sbc_abs?-instance-method","html_id":"sbc_abs?-instance-method","name":"sbc_abs?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":728,"url":null},"def":{"name":"sbc_abs?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == SBC_ABS"}},{"id":"sbc_imm?-instance-method","html_id":"sbc_imm?-instance-method","name":"sbc_imm?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":703,"url":null},"def":{"name":"sbc_imm?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == SBC_IMM"}},{"id":"sbc_zero?-instance-method","html_id":"sbc_zero?-instance-method","name":"sbc_zero?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":715,"url":null},"def":{"name":"sbc_zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == SBC_ZERO"}},{"id":"sec?-instance-method","html_id":"sec?-instance-method","name":"sec?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":784,"url":null},"def":{"name":"sec?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == SEC"}},{"id":"sta_abs?-instance-method","html_id":"sta_abs?-instance-method","name":"sta_abs?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":658,"url":null},"def":{"name":"sta_abs?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == STA_ABS"}},{"id":"sta_zero?-instance-method","html_id":"sta_zero?-instance-method","name":"sta_zero?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":648,"url":null},"def":{"name":"sta_zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == STA_ZERO"}},{"id":"stx_abs?-instance-method","html_id":"stx_abs?-instance-method","name":"stx_abs?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":531,"url":null},"def":{"name":"stx_abs?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == STX_ABS"}},{"id":"stx_zero?-instance-method","html_id":"stx_zero?-instance-method","name":"stx_zero?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":510,"url":null},"def":{"name":"stx_zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == STX_ZERO"}},{"id":"stx_zero_y?-instance-method","html_id":"stx_zero_y?-instance-method","name":"stx_zero_y?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":520,"url":null},"def":{"name":"stx_zero_y?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == STX_ZERO_Y"}},{"id":"sty_abs?-instance-method","html_id":"sty_abs?-instance-method","name":"sty_abs?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":563,"url":null},"def":{"name":"sty_abs?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == STY_ABS"}},{"id":"sty_zero?-instance-method","html_id":"sty_zero?-instance-method","name":"sty_zero?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":541,"url":null},"def":{"name":"sty_zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == STY_ZERO"}},{"id":"sty_zero_x?-instance-method","html_id":"sty_zero_x?-instance-method","name":"sty_zero_x?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":552,"url":null},"def":{"name":"sty_zero_x?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == STY_ZERO_X"}}],"macros":[],"types":[]},{"html_id":"6502-cr/Memory","path":"Memory.html","kind":"struct","full_name":"Memory","name":"Memory","abstract":false,"superclass":{"html_id":"6502-cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"6502-cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"6502-cr/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"6502-cr/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"6502-cr","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/6502.cr","line_number":390,"url":null},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"id":"[](index:UInt16)-instance-method","html_id":"[](index:UInt16)-instance-method","name":"[]","doc":"Read at a 16-bit address","summary":"<p>Read at a 16-bit address</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt16"}],"args_string":"(index : UInt16)","args_html":"(index : UInt16)","location":{"filename":"src/6502.cr","line_number":403,"url":null},"def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt16"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index]"}},{"id":"[](index:UInt8)-instance-method","html_id":"[](index:UInt8)-instance-method","name":"[]","doc":"Read at an 8-bit address","summary":"<p>Read at an 8-bit address</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt8"}],"args_string":"(index : UInt8)","args_html":"(index : UInt8)","location":{"filename":"src/6502.cr","line_number":408,"url":null},"def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index]"}},{"id":"[]=(index:Int32,value:UInt8)-instance-method","html_id":"[]=(index:Int32,value:UInt8)-instance-method","name":"[]=","doc":"Use a 32-bit address to store an 8-bit value","summary":"<p>Use a 32-bit address to store an 8-bit value</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"Int32"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"args_string":"(index : Int32, value : UInt8)","args_html":"(index : Int32, value : UInt8)","location":{"filename":"src/6502.cr","line_number":413,"url":null},"def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"Int32"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index] = value"}},{"id":"[]=(index:UInt16,value:UInt8)-instance-method","html_id":"[]=(index:UInt16,value:UInt8)-instance-method","name":"[]=","doc":"Use a 16-bit address to store an 8-bit value","summary":"<p>Use a 16-bit address to store an 8-bit value</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt16"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"args_string":"(index : UInt16, value : UInt8)","args_html":"(index : UInt16, value : UInt8)","location":{"filename":"src/6502.cr","line_number":418,"url":null},"def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt16"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index] = value"}},{"id":"[]=(index:UInt8,value:UInt8)-instance-method","html_id":"[]=(index:UInt8,value:UInt8)-instance-method","name":"[]=","doc":"Use an 8-bit address to store an 8-bit value","summary":"<p>Use an 8-bit address to store an 8-bit value</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt8"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"args_string":"(index : UInt8, value : UInt8)","args_html":"(index : UInt8, value : UInt8)","location":{"filename":"src/6502.cr","line_number":423,"url":null},"def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":"UInt8"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"UInt8"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.data[index] = value"}},{"id":"data:Array(UInt8)-instance-method","html_id":"data:Array(UInt8)-instance-method","name":"data","doc":"The actual stored data\n  The first page ($0000 - $00FF) is called the zero page\n  The second page ($0100 - $01FF) is reserved for the system stack and cannot be relocated\n  The last 6 bytes are reserved for the following\n      $FFFA-$FFFB : non-maskable interrupt handler\n      $FFFC-$FFFD : power reset handler\n      $FFFE-$FFFF : BRK/interrupt request handler\n  Any other locations are free to use by the user\ngetter data = StaticArray(UInt8, 65536).new(0)","summary":"<p>The actual stored data   The first page ($0000 - $00FF) is called the zero page   The second page ($0100 - $01FF) is reserved for the system stack and cannot be relocated   The last 6 bytes are reserved for the following       $FFFA-$FFFB : non-maskable interrupt handler       $FFFC-$FFFD : power reset handler       $FFFE-$FFFF : BRK/interrupt request handler   Any other locations are free to use by the user getter data = StaticArray(UInt8, 65536).new(0)</p>","abstract":false,"args":[],"args_string":" : Array(UInt8)","args_html":" : Array(UInt8)","location":{"filename":"src/6502.cr","line_number":400,"url":null},"def":{"name":"data","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@data"}}],"macros":[],"types":[]}]}})